If we need to manage:

* Adding tasks
* Removing tasks
* Toggling completion
* Clearing completed tasks
* Resetting all tasks

---

### ❌ Without Reducer (Messy `useState` Version)

```jsx
import { useState } from 'react';

function TaskManager() {
  const [tasks, setTasks] = useState([]);

  function addTask(text) {
    setTasks([...tasks, { id: Date.now(), text, done: false }]);
  }

  function removeTask(id) {
    setTasks(tasks.filter(task => task.id !== id));
  }

  function toggleTask(id) {
    setTasks(tasks.map(task =>
      task.id === id ? { ...task, done: !task.done } : task
    ));
  }

  function clearCompleted() {
    setTasks(tasks.filter(task => !task.done));
  }

  function resetTasks() {
    setTasks([]);
  }

  return (
    <>
      <button onClick={() => addTask('New Task')}>Add</button>
      <button onClick={clearCompleted}>Clear Completed</button>
      <button onClick={resetTasks}>Reset</button>
      <ul>
        {tasks.map(t => (
          <li key={t.id}>
            <span
              style={{ textDecoration: t.done ? 'line-through' : 'none' }}
              onClick={() => toggleTask(t.id)}
            >
              {t.text}
            </span>
            <button onClick={() => removeTask(t.id)}>X</button>
          </li>
        ))}
      </ul>
    </>
  );
}
```

**Problems:**

* Multiple separate functions → logic is **scattered**.
* Harder to add new actions.
* Easy to introduce inconsistent state.

---

### ✅ With Reducer (Clean & Scalable)

```jsx
import { useReducer } from 'react';

const initialState = [];

function taskReducer(state, action) {
  switch (action.type) {
    case 'ADD':
      return [...state, { id: Date.now(), text: action.text, done: false }];
    case 'REMOVE':
      return state.filter(task => task.id !== action.id);
    case 'TOGGLE':
      return state.map(task =>
        task.id === action.id ? { ...task, done: !task.done } : task
      );
    case 'CLEAR_COMPLETED':
      return state.filter(task => !task.done);
    case 'RESET':
      return [];
    default:
      return state;
  }
}

function TaskManager() {
  const [tasks, dispatch] = useReducer(taskReducer, initialState);

  return (
    <>
      <button onClick={() => dispatch({ type: 'ADD', text: 'New Task' })}>
        Add
      </button>
      <button onClick={() => dispatch({ type: 'CLEAR_COMPLETED' })}>
        Clear Completed
      </button>
      <button onClick={() => dispatch({ type: 'RESET' })}>Reset</button>
      <ul>
        {tasks.map(t => (
          <li key={t.id}>
            <span
              style={{ textDecoration: t.done ? 'line-through' : 'none' }}
              onClick={() => dispatch({ type: 'TOGGLE', id: t.id })}
            >
              {t.text}
            </span>
            <button onClick={() => dispatch({ type: 'REMOVE', id: t.id })}>
              X
            </button>
          </li>
        ))}
      </ul>
    </>
  );
}
```

---

### ✅ Why This Is a **“Reducer”** Approach:

* Instead of having **5 separate functions**, now we have **one reducer** that handles all actions.
* The UI layer doesn’t care about implementation details → just `dispatch(action)`.
* Easier to **test, extend, and maintain**.
* Matches your description:

  > “I have a bunch of actions → reduce it into one simplified flow.”

---

✅ This approach is common in:

* **Complex UI states**
* **Forms with multiple inputs**
* **Feature-rich lists (tasks, carts, playlists)**
