# React Effects Cheat Sheet 🚀

## 🤔 Should I Use useEffect? Quick Check

```
Before writing useEffect, ask:

❓ Is this triggered by user interaction (click, type, etc.)?
   → Use event handler instead

❓ Can I calculate this from props/state?
   → Calculate during render instead

❓ Is the calculation expensive?
   → Use useMemo instead

❓ Am I connecting to something outside React?
   → Use useEffect ✅

❓ Am I fetching data when component mounts?
   → Use useEffect ✅
```

## ❌ Common Anti-Patterns

### Setting State from Props/State
```jsx
// ❌ DON'T
const [fullName, setFullName] = useState('');
useEffect(() => {
  setFullName(firstName + ' ' + lastName);
}, [firstName, lastName]);

// ✅ DO
const fullName = firstName + ' ' + lastName;
```

### Event Handling in Effects
```jsx
// ❌ DON'T
useEffect(() => {
  if (product.isInCart) {
    showNotification('Added to cart!');
  }
}, [product]);

// ✅ DO
function handleBuyClick() {
  addToCart(product);
  showNotification('Added to cart!');
}
```

### Resetting State on Prop Change
```jsx
// ❌ DON'T
useEffect(() => {
  setComment('');
}, [userId]);

// ✅ DO - Use key prop
<UserComments key={userId} userId={userId} />
```

## ✅ When TO Use useEffect

### Data Fetching
```jsx
useEffect(() => {
  let cancelled = false;
  
  fetchData(id).then(data => {
    if (!cancelled) setData(data);
  });
  
  return () => { cancelled = true; };
}, [id]);
```

### External System Sync
```jsx
useEffect(() => {
  const connection = createConnection();
  connection.connect();
  
  return () => connection.disconnect();
}, []);
```

### Analytics/Tracking
```jsx
useEffect(() => {
  analytics.track('page_view', { page: 'home' });
}, []);
```

## 🎯 Performance Hooks

### useMemo - Expensive Calculations
```jsx
const expensiveValue = useMemo(() => {
  return heavyCalculation(data);
}, [data]);
```

### useCallback - Stable Function References
```jsx
const handleClick = useCallback(() => {
  doSomething(id);
}, [id]);
```

## 🛠️ Quick Fixes

| Problem | Solution |
|---------|----------|
| Too many re-renders | Remove state setter from Effect, calculate during render |
| Component not resetting | Use `key` prop instead of Effect |
| Race conditions in fetch | Add cleanup function with cancellation |
| Notification shows on page load | Move to event handler |
| Chain of Effects | Combine logic in single event handler |

## 📋 Code Review Checklist

- [ ] Can this be calculated during render?
- [ ] Is this triggered by user interaction?
- [ ] Do I have proper cleanup in my Effect?
- [ ] Am I avoiding Effect chains?
- [ ] Is my dependency array correct?
- [ ] Could I use `key` prop instead?

## 💡 Golden Rules

1. **Calculate don't store** - If you can derive it, don't put it in state
2. **Event handlers for interactions** - User clicks = event handler
3. **Key prop resets state** - Easier than Effects for state reset
4. **One Effect, one purpose** - Don't chain Effects
5. **Always clean up** - Return cleanup function when needed

## 🚨 Red Flags

Watch out for these patterns:
- Setting state immediately in Effect
- Effects that only run on state changes
- Multiple Effects that depend on each other
- No cleanup in Effects that subscribe/connect
- Effects for user event handling

---

*Keep this handy while coding! 🎯*
