When we think about React hooks, most developers jump to `useState` or `useEffect`. But there’s another powerful hook you’ll often need: **`useRef`**.
If you’ve ever wondered **how to access DOM elements, store values without re-rendering, or manage timers in React**, `useRef` is the tool for the job.

## **1. What is `useRef`?**

`useRef` is a React hook that gives you a **mutable object** with a `.current` property.

**Syntax:**

```jsx
const myRef = useRef(initialValue);
```

* `myRef` is an object like this:

  ```js
  { current: initialValue }
  ```
* Updating `myRef.current` **does NOT cause a re-render**.
* Unlike `useState`, `useRef` is **persistent** across renders.

---

## **2. Why is `useRef` Useful?**

There are two main reasons to use `useRef`:

1. **Access DOM elements directly** (like `document.querySelector` but React-safe)
2. **Store values without causing re-renders** (like a variable that survives re-renders)

---

## **3. Common Use Cases of `useRef`**

---

### ✅ **Case 1: Accessing DOM Elements**

**Example: Focus an input when a button is clicked**

```jsx
import { useRef } from 'react';

function FocusInput() {
  const inputRef = useRef(null);

  function handleClick() {
    inputRef.current.focus(); // Direct DOM manipulation
  }

  return (
    <>
      <input ref={inputRef} type="text" />
      <button onClick={handleClick}>Focus Input</button>
    </>
  );
}
```

✔ `ref={inputRef}` connects the DOM element to the ref object.
✔ `inputRef.current` points to the actual DOM node.

---

### ✅ **Case 2: Storing Values Without Re-rendering**

**Example: Track previous state**

```jsx
import { useState, useEffect, useRef } from 'react';

function PreviousValueExample() {
  const [count, setCount] = useState(0);
  const prevCountRef = useRef(0);

  useEffect(() => {
    prevCountRef.current = count;
  }, [count]);

  return (
    <div>
      <p>Current: {count}</p>
      <p>Previous: {prevCountRef.current}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

✔ `prevCountRef` stores the old value **without re-rendering**.

---

### ✅ **Case 3: Managing Timers or Intervals**

**Example: Pause and resume a timer**

```jsx
import { useState, useRef } from 'react';

function Timer() {
  const [time, setTime] = useState(0);
  const intervalRef = useRef(null);

  function start() {
    if (!intervalRef.current) {
      intervalRef.current = setInterval(() => {
        setTime(prev => prev + 1);
      }, 1000);
    }
  }

  function stop() {
    clearInterval(intervalRef.current);
    intervalRef.current = null;
  }

  return (
    <>
      <p>{time}s</p>
      <button onClick={start}>Start</button>
      <button onClick={stop}>Stop</button>
    </>
  );
}
```

✔ Using `useRef` avoids creating multiple intervals.

---

### ✅ **Case 4: Avoid Recreating Expensive Objects**

Sometimes, you need an object or value that **should not reset on every render** but doesn’t need to trigger re-render when changed.

```jsx
const expensiveObjectRef = useRef(createExpensiveObject());
```

---

## **4. Important Things to Remember**

* Updating `ref.current` **does not trigger re-render**.
* Don’t use `useRef` for derived state. Use `useState` for UI updates.
* Refs are useful for **imperative actions** (DOM, timers), not for controlling the main UI logic.

---

## **5. When NOT to Use `useRef`**

❌ Don’t use it to **mirror state**
❌ Don’t use it for **data that affects rendering**
(Use `useState` or `useReducer` instead.)
